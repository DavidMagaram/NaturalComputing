<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>ActModel</title>
<link rel="stylesheet" href="./style.css">
<script src="./sliders.js"></script>
<script src="../artistoo_minimal/build/artistoo.js"></script>
<script>
"use strict"


/*	----------------------------------
	CONFIGURATION SETTINGS
	----------------------------------
*/
let config = {

	// Grid settings
	ndim : 2,
	field_size : [200,200],
	
	// CPM parameters and configuration
	conf : {
		// Basic CPM parameters
		torus : [true,true],// Border. True = wrapped. False=borders.
		seed : 1,							// Seed for random number generation.
		T : 20,								// CPM temperature
		
		// Constraint parameters. 
		// Mostly these have the format of an array in which each element specifies the
		// parameter value for one of the cellkinds on the grid.
		// First value is always cellkind 0 (the background) and is often not used.
				
		// Adhesion parameters: [background, obstacle, moving cell]
		J: [[0,20,20], [20,0,1000], [20,0,0]],
		
		// VolumeConstraint parameters
		LAMBDA_V: [0,500,50],					// Obstacle rigid, moving cell flexible
		V: [0,150,200],							// Same size for both
		
		// PerimeterConstraint parameters
		LAMBDA_P: [0,200,2],						
		P : [0,10,180],						
		
		// ActivityConstraint parameters
		LAMBDA_ACT : [0,0,200],				// Obstacle has NO activity
		MAX_ACT : [0,0,20],					// Obstacle cannot move
		ACT_MEAN : "geometric"				

	},
	
	// Simulation setup and configuration
	simsettings : {
	
		// Cells on the grid: [1 obstacle, 1 moving cell]
		NRCELLS : [25, 50],			// 64 does not work but 70 does....			For cells, 50 works but 100 does not...

		// Spacing 100 = 4
		// Spacing 68 = 9 (68 because at 66 there were some artefacts)
		// Spacingg 50 = 16
		// Spacing 38 = 25
		// No config (so far) works with 36 obstacles

		// Runtime etc
		BURNIN : 500,
		RUNTIME : 1000,
		RUNTIME_BROWSER : "Inf",
		
		FRAMERATE : 1,
		// Visualization
		CANVASCOLOR : "eaecef",
		CELLCOLOR : ["CCCCCC", "000000"],  // Blue obstacle, black moving cell
		ACTCOLOR : [false, true],					
		SHOWBORDERS : [false, false],				
		zoom : 2,							
		
		// Output images
		//SAVEIMG : true,					
		//IMGFRAMERATE : 1,					
		//SAVEPATH : "output/img/ActModel",	
		//EXPNAME : "ActModel",					
		
		// Output stats etc
		STATSOUT : { browser: false, node: true },
		LOGRATE : 10							

	}
}
/*	---------------------------------- */
let sim




function step(){
	sim.step()

	if( sim.conf["RUNTIME_BROWSER"] == "Inf" | sim.time+1 < sim.conf["RUNTIME_BROWSER"] ){
		requestAnimationFrame( step )
	}
}

function setSliders(){
	document.getElementById("mact").value = config.conf.MAX_ACT[2]  // Changed to index 2
	document.getElementById("lact").value = config.conf.LAMBDA_ACT[2]  // Changed to index 2
}






function initialize(){
	// Create simulation but DON'T auto-seed obstacles
	let customConfig = Object.assign({}, config.simsettings)
	customConfig.NRCELLS = [0, 0]  // 0 obstacles (we'll place manually), 100 moving cells
	
	sim = new CPM.Simulation( config, customConfig )
	
	// Now manually place obstacles at specific positions
	placeObstacles()
	
	step()
}

function placeObstacles(){
	let obstacleID = 1
	let obstacleSize = 10
	let fieldWidth = config.field_size[0]
	let fieldHeight = config.field_size[1]
	
	// Grid pattern that adapts to field size
	let spacing = 38  // Distance between obstacles (keep even (2,4,6...))
	for(let x = spacing/2; x < fieldWidth; x += spacing){
		for(let y = spacing/2; y < fieldHeight; y += spacing){
			placeCircularObstacle(x, y, obstacleSize, obstacleID)
			obstacleID++
		}
	}
}

function placeCircularObstacle(centerX, centerY, radius, cellID){
	// Draw a circular obstacle
	for(let x = centerX - radius; x <= centerX + radius; x++){
		for(let y = centerY - radius; y <= centerY + radius; y++){
			// Check if pixel is within circle
			let dx = x - centerX
			let dy = y - centerY
			if(dx*dx + dy*dy <= radius*radius){
				sim.C.setpix([x, y], cellID)
			}
		}
	}
}

function placeSquareObstacle(centerX, centerY, size, cellID){
	// Draw a square obstacle
	let halfSize = Math.floor(size / 2)
	for(let x = centerX - halfSize; x <= centerX + halfSize; x++){
		for(let y = centerY - halfSize; y <= centerY + halfSize; y++){
			sim.C.setpix([x, y], cellID)
		}
	}
}






// No custom methods.
</script>
</head>
<body onload="initialize();setSliders();initializeSliders()">
<h1>Migrating cell with some obstacles + sliders for ACT</h1>


<table width="400px">
<tr>
	<td style="width:20%">max<sub>act</sub></td>
	<td style="width:5%">0</td>
	<td style="width:70%"> 
		<div class="range-wrap">
		  <input type="range" class="range" min="0" max="100" id="mact" oninput="sim.C.getConstraint('ActivityConstraint').conf.MAX_ACT[2]=this.value" >
		  <output class="bubble"></output>
		</div>
	</td>
	<td style="width:5%">100</td>
</tr>
<tr>
	<td style="width:20%">&lambda;<sub>act</sub></td>
	<td style="width:5%">0</td>
	<td style="width:70%"> 
		<div class="range-wrap">
		  <input type="range" class="range" min="0" max="1000" id="lact" oninput="sim.C.getConstraint('ActivityConstraint').conf.LAMBDA_ACT[2]=this.value">
		  <output class="bubble"></output>
		</div>
	</td>
	<td style="width:5%">1000</td>
</tr>
</table>
<br>



</body>
</html>